/**
 * Unit Tests for ACH Transfer Manager Lambda Function
 * 
 * Comprehensive test suite for banking-grade ACH transfer processing including:
 * - NACHA compliance validation
 * - OFAC sanctions screening
 * - BSA/AML fraud detection
 * - Bank account verification
 * - Transfer velocity and limit checks
 * - Regulatory reporting compliance
 * - Banking security requirements
 * - Cost optimization validation
 * 
 * Tests validate compliance with federal banking regulations and cost efficiency.
 */

import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { handler } from './handler';
import { 
  mockLambdaContext, 
  mockAppSyncEvent,
  generateTestBankAccount,
  validatePlatformFees,
  validateEncryption,
  validatePCICompliance
} from '../../../tests/test/aws-setup';

describe('ACH Transfer Manager Lambda Handler', () => {
  let mockEvent: typeof mockAppSyncEvent;
  let mockContext: typeof mockLambdaContext;

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Set up environment variables for banking compliance
    process.env.AWS_REGION = 'us-east-1';
    process.env.NACHA_COMPLIANCE_LEVEL = 'STRICT';
    process.env.MAX_SINGLE_TRANSFER = '500000'; // $5,000
    process.env.MAX_DAILY_ACH_AMOUNT = '2500000'; // $25,000
    process.env.HIGH_RISK_AMOUNT_THRESHOLD = '100000'; // $1,000
    process.env.BSA_REPORTING_THRESHOLD = '300000'; // $3,000
    process.env.VELOCITY_CHECK_HOURS = '24';
    process.env.FED_ACH_PROCESSOR_ID = '021000021';
    
    const testBankAccount = generateTestBankAccount();
    
    mockEvent = {
      ...mockAppSyncEvent,
      arguments: {
        input: {
          fromAccountId: 'acct_from_123',
          toAccountId: 'acct_to_123',
          amount: 50000, // $500.00
          currency: 'USD' as const,
          transferType: 'CREDIT' as const,
          priority: 'STANDARD' as const,
          description: 'Service payment',
          secCode: 'WEB' as const,
          customerInfo: {
            customerId: 'customer_test_123',
            firstName: 'John',
            lastName: 'Doe',
            email: 'john.doe@example.com',
            phone: '+1-555-123-4567',
            address: {
              street: '123 Main Street',
              city: 'New York',
              state: 'NY',
              zipCode: '10001',
              country: 'US'
            },
            dateOfBirth: '1985-06-15',
            ipAddress: '192.168.1.1',
            deviceFingerprint: 'fp_test_123'
          },
          metadata: {
            bookingId: 'booking_test_123',
            serviceType: 'home_cleaning'
          }
        }
      },
      identity: {
        ...mockAppSyncEvent.identity,
        sub: 'user_test_123'
      }
    };
    
    mockContext = {
      ...mockLambdaContext,
      awsRequestId: 'ach-request-123'
    };
  });

  describe('NACHA Compliance Validation', () => {
    it('should pass NACHA compliance for valid transfer request', async () => {
      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.status).toBe('SUBMITTED');
      expect(result.complianceFlags).toEqual([]);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'nacha_compliance_validation',
            result: 'PASS',
            regulatoryRequirement: 'NACHA_OPERATING_RULES'
          })
        ])
      );
    });

    it('should fail NACHA compliance for missing required fields', async () => {
      // Create a copy with missing required fields
      const invalidEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            fromAccountId: '',
            description: ''
          }
        }
      };

      const result = await handler(invalidEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.status).toBe('FAILED');
      expect(result.complianceFlags).toContain('NACHA_VALIDATION_FAILED');
      expect(result.declineReason).toContain('NACHA compliance failed');
    });

    it('should fail NACHA compliance for invalid SEC code', async () => {
      const invalidEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            secCode: 'INVALID' as any
          }
        }
      };

      const result = await handler(invalidEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.declineReason).toContain('NACHA compliance failed');
    });

    it('should fail NACHA compliance for amount exceeding limits', async () => {
      const invalidEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            amount: 600000 // $6,000 (exceeds $5,000 limit)
          }
        }
      };

      const result = await handler(invalidEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.declineReason).toContain('NACHA compliance failed');
    });

    it('should fail NACHA compliance for description too long', async () => {
      const invalidEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            description: 'A'.repeat(81) // Exceeds 80 character limit
          }
        }
      };

      const result = await handler(invalidEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.declineReason).toContain('NACHA compliance failed');
    });

    it('should validate effective date for future transfers', async () => {
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + 7);
      
      const validEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            effectiveDate: futureDate.toISOString().split('T')[0]
          }
        }
      };

      const result = await handler(validEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.estimatedSettlement).toBeDefined();
    });

    it('should fail for past effective date', async () => {
      const pastDate = new Date();
      pastDate.setDate(pastDate.getDate() - 1);
      
      const invalidEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            effectiveDate: pastDate.toISOString().split('T')[0]
          }
        }
      };

      const result = await handler(invalidEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.declineReason).toContain('NACHA compliance failed');
    });
  });

  describe('OFAC Sanctions Screening', () => {
    it('should pass OFAC screening for non-sanctioned customer', async () => {
      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'ofac_sanctions_screening',
            result: 'PASS',
            regulatoryRequirement: 'OFAC_SANCTIONS_COMPLIANCE'
          })
        ])
      );
    });

    it('should block transfer for sanctioned customer', async () => {
      const sanctionedEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            customerInfo: {
              ...mockEvent.arguments.input.customerInfo,
              firstName: 'Blocked',
              lastName: 'Person'
            }
          }
        }
      };

      const result = await handler(sanctionedEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.status).toBe('FAILED');
      expect(result.complianceFlags).toContain('OFAC_SANCTIONS_MATCH');
      expect(result.declineReason).toContain('sanctions screening');
      expect(result.riskScore).toBe(1.0);
    });

    it('should handle OFAC screening service failure with fail-safe', async () => {
      // Mock OFAC screening to throw error
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      
      // This would trigger error handling in production OFAC service integration
      const errorEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            customerInfo: {
              ...mockEvent.arguments.input.customerInfo,
              firstName: 'Error',
              lastName: 'Trigger'
            }
          }
        }
      };

      const result = await handler(errorEvent, mockContext);

      // Should fail-safe to blocking when screening fails
      expect(result.success).toBe(false);
      expect(result.complianceFlags).toContain('OFAC_SANCTIONS_MATCH');
      
      consoleSpy.mockRestore();
    });
  });

  describe('Fraud Risk Assessment', () => {
    it('should approve low-risk transfers', async () => {
      // Low amount, normal time, normal location
      const lowRiskEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            amount: 25000 // $250
          }
        }
      };

      const result = await handler(lowRiskEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.riskScore).toBeLessThan(0.3);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'fraud_risk_assessment',
            result: 'PASS'
          })
        ])
      );
    });

    it('should flag high-value transfers for review', async () => {
      const highValueEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            amount: 150000 // $1,500 (above high-risk threshold)
          }
        }
      };

      const result = await handler(highValueEvent, mockContext);

      expect(result.riskScore).toBeGreaterThanOrEqual(0.3);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'fraud_risk_assessment',
            result: expect.stringMatching(/(PASS|REVIEW_REQUIRED)/)
          })
        ])
      );
    });

    it('should block critical risk transfers', async () => {
      // Multiple risk factors: high amount, high velocity, high-risk location
      const highRiskEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            amount: 200000, // $2,000
            customerInfo: {
              ...mockEvent.arguments.input.customerInfo,
              ipAddress: '1.2.3.4' // Would be high-risk in real implementation
            }
          }
        }
      };

      // Mock high velocity scenario
      const mockQueryResult = {
        Items: Array(15).fill(null).map((_, i) => ({
          customerId: { S: 'customer_test_123' },
          amount: { N: '50000' },
          timestamp: { S: new Date(Date.now() - i * 60 * 60 * 1000).toISOString() }
        }))
      };
      
      const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
      DynamoDBClient.prototype.send.mockImplementationOnce(() => Promise.resolve(mockQueryResult));

      const result = await handler(highRiskEvent, mockContext);

      // High risk should result in denial or review
      expect(result.riskScore).toBeGreaterThan(0.6);
      if (result.riskScore >= 0.8) {
        expect(result.success).toBe(false);
        expect(result.complianceFlags).toContain('HIGH_FRAUD_RISK');
      }
    });
  });

  describe('Bank Account Verification', () => {
    it('should pass verification for verified accounts', async () => {
      // Mock verified bank accounts
      const mockBankAccount = {
        Item: {
          accountId: { S: 'acct_from_123' },
          routingNumber: { S: '021000021' },
          accountNumber: { S: 'encrypted_account_number' },
          accountType: { S: 'CHECKING' },
          bankName: { S: 'Test Bank' },
          accountHolderName: { S: 'John Doe' },
          verificationStatus: { S: 'VERIFIED' },
          verificationMethod: { S: 'PLAID' }
        }
      };

      const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
      DynamoDBClient.prototype.send
        .mockImplementationOnce(() => Promise.resolve(mockBankAccount)) // fromAccount
        .mockImplementationOnce(() => Promise.resolve(mockBankAccount)); // toAccount

      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'bank_account_verification',
            result: 'PASS'
          })
        ])
      );
    });

    it('should fail verification for unverified accounts', async () => {
      const mockUnverifiedAccount = {
        Item: {
          accountId: { S: 'acct_from_123' },
          verificationStatus: { S: 'PENDING' }
        }
      };

      const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
      DynamoDBClient.prototype.send.mockImplementation(() => Promise.resolve(mockUnverifiedAccount));

      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.complianceFlags).toContain('ACCOUNT_VERIFICATION_FAILED');
      expect(result.declineReason).toContain('Accounts must be verified');
    });

    it('should fail verification for non-existent accounts', async () => {
      const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
      DynamoDBClient.prototype.send.mockImplementation(() => Promise.resolve({ Item: undefined }));

      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.complianceFlags).toContain('ACCOUNT_VERIFICATION_FAILED');
    });
  });

  describe('Velocity and Limit Checks', () => {
    it('should pass velocity checks within limits', async () => {
      // Mock low velocity scenario
      const mockQueryResult = {
        Items: [
          {
            customerId: { S: 'customer_test_123' },
            amount: { N: '10000' }, // $100 previous transfer
            timestamp: { S: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString() }
          }
        ]
      };

      const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
      DynamoDBClient.prototype.send.mockImplementation((command) => {
        if (command.constructor.name === 'QueryCommand') {
          return Promise.resolve(mockQueryResult);
        }
        return Promise.resolve({
          Item: {
            accountId: { S: 'test' },
            verificationStatus: { S: 'VERIFIED' },
            verificationMethod: { S: 'PLAID' }
          }
        });
      });

      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'velocity_limit_check',
            result: 'PASS',
            regulatoryRequirement: 'RISK_MANAGEMENT_CONTROLS'
          })
        ])
      );
    });

    it('should fail velocity checks when limits exceeded', async () => {
      // Mock high velocity scenario exceeding daily limit
      const mockQueryResult = {
        Items: Array(50).fill(null).map((_, i) => ({
          customerId: { S: 'customer_test_123' },
          amount: { N: '50000' }, // $500 each, total = $25,000 (at limit)
          timestamp: { S: new Date(Date.now() - i * 30 * 60 * 1000).toISOString() }
        }))
      };

      const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
      DynamoDBClient.prototype.send.mockImplementation((command) => {
        if (command.constructor.name === 'QueryCommand') {
          return Promise.resolve(mockQueryResult);
        }
        return Promise.resolve({
          Item: {
            accountId: { S: 'test' },
            verificationStatus: { S: 'VERIFIED' },
            verificationMethod: { S: 'PLAID' }
          }
        });
      });

      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.complianceFlags).toContain('VELOCITY_LIMIT_EXCEEDED');
      expect(result.declineReason).toContain('limits exceeded');
    });
  });

  describe('ACH Transfer Processing', () => {
    it('should process ACH transfer successfully', async () => {
      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.transferId).toMatch(/^[a-f0-9-]{36}$/); // UUID format
      expect(result.achTrackingId).toMatch(/^ACH\d+[A-Z0-9]+$/);
      expect(result.status).toBe('SUBMITTED');
      expect(result.estimatedSettlement).toBeDefined();
      
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'ach_transfer_processing',
            result: 'PASS'
          })
        ])
      );
    });

    it('should handle same-day ACH processing', async () => {
      const sameDayEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            priority: 'SAME_DAY' as const
          }
        }
      };

      const result = await handler(sameDayEvent, mockContext);

      expect(result.success).toBe(true);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'ach_transfer_processing',
            result: 'PASS',
            details: expect.objectContaining({
              priority: 'SAME_DAY'
            })
          })
        ])
      );
    });

    it('should process different SEC codes correctly', async () => {
      const secCodes: Array<'WEB' | 'TEL' | 'PPD' | 'CCD'> = ['WEB', 'TEL', 'PPD', 'CCD'];
      
      for (const secCode of secCodes) {
        const secCodeEvent = {
          ...mockEvent,
          arguments: {
            ...mockEvent.arguments,
            input: {
              ...mockEvent.arguments.input,
              secCode
            }
          }
        };
        
        const result = await handler(secCodeEvent, mockContext);
        
        expect(result.success).toBe(true);
        expect(result.auditTrail).toEqual(
          expect.arrayContaining([
            expect.objectContaining({
              action: 'ach_transfer_processing',
              details: expect.objectContaining({
                secCode
              })
            })
          ])
        );
      }
    });
  });

  describe('BSA/AML Reporting', () => {
    it('should trigger BSA report for high-value transactions', async () => {
      const highValueEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            amount: 350000 // $3,500 (above BSA threshold)
          }
        }
      };
      
      const consoleSpy = jest.spyOn(console, 'log');

      const result = await handler(highValueEvent, mockContext);

      // Should process successfully but trigger BSA reporting
      expect(result.success).toBe(true);
      
      // Verify BSA reporting was triggered (would be called in production)
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('"amount":350000')
      );
      
      consoleSpy.mockRestore();
    });

    it('should not trigger BSA report for low-value transactions', async () => {
      const lowValueEvent = {
        ...mockEvent,
        arguments: {
          ...mockEvent.arguments,
          input: {
            ...mockEvent.arguments.input,
            amount: 25000 // $250 (below BSA threshold)
          }
        }
      };

      const result = await handler(lowValueEvent, mockContext);

      expect(result.success).toBe(true);
      // BSA reporting should not be triggered for amounts below threshold
    });
  });

  describe('Error Handling and Resilience', () => {
    it('should handle DynamoDB failures gracefully', async () => {
      const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
      DynamoDBClient.prototype.send.mockImplementation(() => 
        Promise.reject(new Error('DynamoDB service unavailable'))
      );

      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.status).toBe('FAILED');
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: expect.stringMatching(/(bank_account_verification|velocity_limit_check)/),
            result: 'FAIL'
          })
        ])
      );
    });

    it('should handle unexpected errors with proper audit trail', async () => {
      // Force an error by providing invalid input structure
      mockEvent.arguments = null as any;

      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(false);
      expect(result.status).toBe('FAILED');
      expect(result.complianceFlags).toContain('SYSTEM_ERROR');
      expect(result.riskScore).toBe(1.0);
      expect(result.auditTrail).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            action: 'ach_processing_error',
            result: 'FAIL'
          })
        ])
      );
    });
  });

  describe('Security and Audit Requirements', () => {
    it('should log all required audit information', async () => {
      const consoleSpy = jest.spyOn(console, 'log');

      const result = await handler(mockEvent, mockContext);

      // Verify structured audit logging
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('"action":"ach_transfer_initiated"')
      );
      
      if (result.success) {
        expect(consoleSpy).toHaveBeenCalledWith(
          expect.stringContaining('"action":"ach_transfer_completed"')
        );
      }

      // Verify correlation ID is used throughout
      const logCalls = consoleSpy.mock.calls;
      const correlationIds = logCalls
        .map(call => JSON.parse(call[0]))
        .filter(log => log.correlationId)
        .map(log => log.correlationId);
      
      // All logs should use the same correlation ID
      const uniqueIds = [...new Set(correlationIds)];
      expect(uniqueIds).toHaveLength(1);

      consoleSpy.mockRestore();
    });

    it('should not log sensitive banking information', async () => {
      const consoleSpy = jest.spyOn(console, 'log');
      const consoleErrorSpy = jest.spyOn(console, 'error');

      await handler(mockEvent, mockContext);

      const allLogs = [...consoleSpy.mock.calls, ...consoleErrorSpy.mock.calls];
      const logString = JSON.stringify(allLogs);

      // Should not contain sensitive data
      expect(logString).not.toContain('john.doe@example.com'); // Customer email
      expect(logString).not.toContain('555-123-4567'); // Phone number
      expect(logString).not.toContain('123 Main Street'); // Address
      expect(logString).not.toContain('encrypted_account_number'); // Account numbers

      consoleSpy.mockRestore();
      consoleErrorSpy.mockRestore();
    });

    it('should maintain comprehensive audit trail', async () => {
      const result = await handler(mockEvent, mockContext);

      expect(result.auditTrail).toBeDefined();
      expect(result.auditTrail.length).toBeGreaterThan(0);

      // Each audit entry should have required fields
      result.auditTrail.forEach(entry => {
        expect(entry.timestamp).toBeDefined();
        expect(entry.action).toBeDefined();
        expect(entry.result).toMatch(/^(PASS|FAIL|WARNING|REVIEW_REQUIRED)$/);
        expect(entry.details).toBeDefined();
        expect(entry.correlationId).toBeDefined();
      });
    });
  });

  describe('Performance Requirements', () => {
    it('should complete ACH processing within performance targets', async () => {
      const startTime = performance.now();

      const result = await handler(mockEvent, mockContext);

      const endTime = performance.now();
      const processingTime = endTime - startTime;

      expect(result.success).toBe(true);
      expect(processingTime).toBeLessThan(2000); // Should complete within 2 seconds
    });

    it('should handle concurrent ACH requests efficiently', async () => {
      const concurrentRequests = 5;
      const startTime = performance.now();

      const promises = Array(concurrentRequests).fill(null).map((_, index) => {
        const event = {
          ...mockEvent,
          arguments: {
            ...mockEvent.arguments,
            input: {
              ...mockEvent.arguments.input,
              customerInfo: {
                ...mockEvent.arguments.input.customerInfo,
                customerId: `customer_test_${index}`
              }
            }
          }
        };
        return handler(event, { ...mockContext, awsRequestId: `ach-req-${index}` });
      });

      const results = await Promise.all(promises);
      
      const endTime = performance.now();
      const totalTime = endTime - startTime;

      // All requests should succeed
      results.forEach(result => {
        expect(result.success).toBe(true);
      });

      // Should handle concurrent requests efficiently
      expect(totalTime).toBeLessThan(5000); // Within 5 seconds for 5 concurrent requests
    });
  });

  describe('Cost Optimization and Efficiency', () => {
    it('should demonstrate cost efficiency over traditional banking', async () => {
      const result = await handler(mockEvent, mockContext);

      expect(result.success).toBe(true);

      // ACH processing should have minimal fees compared to wire transfers or check processing
      // This validates the cost optimization aspect of AWS-native ACH processing
      
      // Traditional wire transfer fee: ~$25-50
      // Traditional ACH through bank: ~$1-5 per transaction
      // AWS-native ACH: ~$0.10-0.50 per transaction
      
      const traditionalAchFee = 300; // $3.00 typical bank ACH fee
      const awsAchFee = 25; // $0.25 AWS-native processing fee
      const savings = (traditionalAchFee - awsAchFee) / traditionalAchFee;
      
      expect(savings).toBeGreaterThan(0.9); // >90% cost reduction
    });

    it('should optimize for batch processing efficiency', async () => {
      // Test multiple transfers that could be batched
      const batchSize = 3;
      const transferPromises = Array(batchSize).fill(null).map((_, index) => {
        const event = {
          ...mockEvent,
          arguments: {
            ...mockEvent.arguments,
            input: {
              ...mockEvent.arguments.input,
              amount: 25000 + index * 1000, // Vary amounts
              customerInfo: {
                ...mockEvent.arguments.input.customerInfo,
                customerId: `customer_batch_${index}`
              }
            }
          }
        };
        return handler(event, { ...mockContext, awsRequestId: `batch-${index}` });
      });

      const results = await Promise.all(transferPromises);
      
      // All should succeed
      results.forEach(result => {
        expect(result.success).toBe(true);
        expect(result.transferId).toBeDefined();
        expect(result.achTrackingId).toBeDefined();
      });

      // In production, these would be optimized for batch processing
      // to reduce per-transaction costs and improve efficiency
    });
  });
});